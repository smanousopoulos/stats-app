import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import uuidv4 from 'uuid/v4';
import * as actions from '../actions';
import * as operations from '../operations';
import * as types from '../types';
import reducer from '../reducers';

jest.mock('uuid/v4', () => jest.fn(() => 'random-uuid'));

describe('User actions', () => {
  describe('Set user', () => {
    const userId = 'user-id';
    const expectedAction = {
      type: types.SET_USER,
      payload: {
        userId,
      }
    };

    it('should create an action to set the user', () => {
      expect(actions.setUser(userId)).toEqual(expectedAction);
    });
  });

  describe('Reset user', () => {
    const expectedAction = {
      type: types.RESET_USER,
    };

    it('should create an action to reset the user', () => {
      expect(actions.resetUser()).toEqual(expectedAction);
    });
  });
});

describe('User reducer', () => {
  it('should return the initial state', () => {
    expect(reducer(undefined, {})).toEqual({
      userId: null,
    });
  });

  describe('should handle SET_USER', () => {
    const setUserAction = {
      type: types.SET_USER,
      payload: {
        userId: 'user-1',
      }
    };

    describe('when no initial user', () => {
      const initialState = {};

      it('should add user', () => {
        expect(reducer(initialState, setUserAction)).toEqual({
          userId: 'user-1',
        });
      });
    });

    describe('when existing user', () => {
      const initialState = { userId: 'existing-user' };

      it('should override existing user', () => {
        expect(reducer(initialState, setUserAction)).toEqual({
          userId: 'user-1',
        });
      });
    });
  });

  describe('should handle RESET_USER', () => {
    const resetUserAction = {
      type: types.RESET_USER,
    };

    describe('when no initial user', () => {
      const initialState = {};

      it('should leave state unchanged', () => {
        expect(reducer(initialState, resetUserAction)).toEqual({
          userId: null,
        });
      });
    });

    describe('when existing user', () => {
      const initialState = { userId: 'existing-user' };

      it('should override existing user', () => {
        expect(reducer(initialState, resetUserAction)).toEqual({
          userId: null,
        });
      });
    });
  });
});

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe('User operations', () => {
  describe('Set user initial', () => {
    describe('when no userId in state', () => {
      const store = mockStore({ user: {
        userId: null,
      }});

      beforeEach(() => {
        store.dispatch(operations.setUserInitial());
      });

      it('should dispatch SET_USER action with autogenerated uuid', () => {
        expect(uuidv4).toHaveBeenCalledTimes(1);
        expect(store.getActions()).toEqual([{
          type: types.SET_USER,
          payload: {
            userId: 'random-uuid'
          }
        }]);
      });
    });

    describe('when userId already in state', () => {
      const store = mockStore({ user: {
        userId: 'existing-user',
      }});

      beforeEach(() => {
        store.dispatch(operations.setUserInitial());
      });

      it('should perform no operation', () => {
        expect(store.getActions()).toEqual([]);
      });
    });
  });
});